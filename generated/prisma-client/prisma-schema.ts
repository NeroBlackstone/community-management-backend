// Code generated by Prisma (prisma@1.31.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type Activity {
  id: ID!
  title: String!
  content: String!
  owner: User!
  startAt: DateTime!
  place: String!
  status: Status!
  reply: String
}

type ActivityConnection {
  pageInfo: PageInfo!
  edges: [ActivityEdge]!
  aggregate: AggregateActivity!
}

input ActivityCreateInput {
  id: ID
  title: String!
  content: String!
  owner: UserCreateOneWithoutActivitiesInput!
  startAt: DateTime!
  place: String!
  status: Status!
  reply: String
}

input ActivityCreateManyWithoutOwnerInput {
  create: [ActivityCreateWithoutOwnerInput!]
  connect: [ActivityWhereUniqueInput!]
}

input ActivityCreateWithoutOwnerInput {
  id: ID
  title: String!
  content: String!
  startAt: DateTime!
  place: String!
  status: Status!
  reply: String
}

type ActivityEdge {
  node: Activity!
  cursor: String!
}

enum ActivityOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  content_ASC
  content_DESC
  startAt_ASC
  startAt_DESC
  place_ASC
  place_DESC
  status_ASC
  status_DESC
  reply_ASC
  reply_DESC
}

type ActivityPreviousValues {
  id: ID!
  title: String!
  content: String!
  startAt: DateTime!
  place: String!
  status: Status!
  reply: String
}

input ActivityScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  startAt: DateTime
  startAt_not: DateTime
  startAt_in: [DateTime!]
  startAt_not_in: [DateTime!]
  startAt_lt: DateTime
  startAt_lte: DateTime
  startAt_gt: DateTime
  startAt_gte: DateTime
  place: String
  place_not: String
  place_in: [String!]
  place_not_in: [String!]
  place_lt: String
  place_lte: String
  place_gt: String
  place_gte: String
  place_contains: String
  place_not_contains: String
  place_starts_with: String
  place_not_starts_with: String
  place_ends_with: String
  place_not_ends_with: String
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  reply: String
  reply_not: String
  reply_in: [String!]
  reply_not_in: [String!]
  reply_lt: String
  reply_lte: String
  reply_gt: String
  reply_gte: String
  reply_contains: String
  reply_not_contains: String
  reply_starts_with: String
  reply_not_starts_with: String
  reply_ends_with: String
  reply_not_ends_with: String
  AND: [ActivityScalarWhereInput!]
  OR: [ActivityScalarWhereInput!]
  NOT: [ActivityScalarWhereInput!]
}

type ActivitySubscriptionPayload {
  mutation: MutationType!
  node: Activity
  updatedFields: [String!]
  previousValues: ActivityPreviousValues
}

input ActivitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ActivityWhereInput
  AND: [ActivitySubscriptionWhereInput!]
  OR: [ActivitySubscriptionWhereInput!]
  NOT: [ActivitySubscriptionWhereInput!]
}

input ActivityUpdateInput {
  title: String
  content: String
  owner: UserUpdateOneRequiredWithoutActivitiesInput
  startAt: DateTime
  place: String
  status: Status
  reply: String
}

input ActivityUpdateManyDataInput {
  title: String
  content: String
  startAt: DateTime
  place: String
  status: Status
  reply: String
}

input ActivityUpdateManyMutationInput {
  title: String
  content: String
  startAt: DateTime
  place: String
  status: Status
  reply: String
}

input ActivityUpdateManyWithoutOwnerInput {
  create: [ActivityCreateWithoutOwnerInput!]
  delete: [ActivityWhereUniqueInput!]
  connect: [ActivityWhereUniqueInput!]
  set: [ActivityWhereUniqueInput!]
  disconnect: [ActivityWhereUniqueInput!]
  update: [ActivityUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [ActivityUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [ActivityScalarWhereInput!]
  updateMany: [ActivityUpdateManyWithWhereNestedInput!]
}

input ActivityUpdateManyWithWhereNestedInput {
  where: ActivityScalarWhereInput!
  data: ActivityUpdateManyDataInput!
}

input ActivityUpdateWithoutOwnerDataInput {
  title: String
  content: String
  startAt: DateTime
  place: String
  status: Status
  reply: String
}

input ActivityUpdateWithWhereUniqueWithoutOwnerInput {
  where: ActivityWhereUniqueInput!
  data: ActivityUpdateWithoutOwnerDataInput!
}

input ActivityUpsertWithWhereUniqueWithoutOwnerInput {
  where: ActivityWhereUniqueInput!
  update: ActivityUpdateWithoutOwnerDataInput!
  create: ActivityCreateWithoutOwnerInput!
}

input ActivityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  owner: UserWhereInput
  startAt: DateTime
  startAt_not: DateTime
  startAt_in: [DateTime!]
  startAt_not_in: [DateTime!]
  startAt_lt: DateTime
  startAt_lte: DateTime
  startAt_gt: DateTime
  startAt_gte: DateTime
  place: String
  place_not: String
  place_in: [String!]
  place_not_in: [String!]
  place_lt: String
  place_lte: String
  place_gt: String
  place_gte: String
  place_contains: String
  place_not_contains: String
  place_starts_with: String
  place_not_starts_with: String
  place_ends_with: String
  place_not_ends_with: String
  status: Status
  status_not: Status
  status_in: [Status!]
  status_not_in: [Status!]
  reply: String
  reply_not: String
  reply_in: [String!]
  reply_not_in: [String!]
  reply_lt: String
  reply_lte: String
  reply_gt: String
  reply_gte: String
  reply_contains: String
  reply_not_contains: String
  reply_starts_with: String
  reply_not_starts_with: String
  reply_ends_with: String
  reply_not_ends_with: String
  AND: [ActivityWhereInput!]
  OR: [ActivityWhereInput!]
  NOT: [ActivityWhereInput!]
}

input ActivityWhereUniqueInput {
  id: ID
}

type Address {
  id: ID!
  building: Int!
  unit: Int!
  room: Int!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

type AddressConnection {
  pageInfo: PageInfo!
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

input AddressCreateInput {
  id: ID
  building: Int!
  unit: Int!
  room: Int!
  users: UserCreateManyWithoutAddressInput
}

input AddressCreateOneWithoutUsersInput {
  create: AddressCreateWithoutUsersInput
  connect: AddressWhereUniqueInput
}

input AddressCreateWithoutUsersInput {
  id: ID
  building: Int!
  unit: Int!
  room: Int!
}

type AddressEdge {
  node: Address!
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  building_ASC
  building_DESC
  unit_ASC
  unit_DESC
  room_ASC
  room_DESC
}

type AddressPreviousValues {
  id: ID!
  building: Int!
  unit: Int!
  room: Int!
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
  AND: [AddressSubscriptionWhereInput!]
  OR: [AddressSubscriptionWhereInput!]
  NOT: [AddressSubscriptionWhereInput!]
}

input AddressUpdateInput {
  building: Int
  unit: Int
  room: Int
  users: UserUpdateManyWithoutAddressInput
}

input AddressUpdateManyMutationInput {
  building: Int
  unit: Int
  room: Int
}

input AddressUpdateOneWithoutUsersInput {
  create: AddressCreateWithoutUsersInput
  update: AddressUpdateWithoutUsersDataInput
  upsert: AddressUpsertWithoutUsersInput
  delete: Boolean
  disconnect: Boolean
  connect: AddressWhereUniqueInput
}

input AddressUpdateWithoutUsersDataInput {
  building: Int
  unit: Int
  room: Int
}

input AddressUpsertWithoutUsersInput {
  update: AddressUpdateWithoutUsersDataInput!
  create: AddressCreateWithoutUsersInput!
}

input AddressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  building: Int
  building_not: Int
  building_in: [Int!]
  building_not_in: [Int!]
  building_lt: Int
  building_lte: Int
  building_gt: Int
  building_gte: Int
  unit: Int
  unit_not: Int
  unit_in: [Int!]
  unit_not_in: [Int!]
  unit_lt: Int
  unit_lte: Int
  unit_gt: Int
  unit_gte: Int
  room: Int
  room_not: Int
  room_in: [Int!]
  room_not_in: [Int!]
  room_lt: Int
  room_lte: Int
  room_gt: Int
  room_gte: Int
  users_every: UserWhereInput
  users_some: UserWhereInput
  users_none: UserWhereInput
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
}

input AddressWhereUniqueInput {
  id: ID
}

type Advice {
  id: ID!
  title: String!
  content: String!
  owner: User!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
}

type AdviceConnection {
  pageInfo: PageInfo!
  edges: [AdviceEdge]!
  aggregate: AggregateAdvice!
}

input AdviceCreateInput {
  id: ID
  title: String!
  content: String!
  owner: UserCreateOneWithoutAdvicesInput!
  comments: CommentCreateManyWithoutAdvicesInput
}

input AdviceCreateManyWithoutOwnerInput {
  create: [AdviceCreateWithoutOwnerInput!]
  connect: [AdviceWhereUniqueInput!]
}

input AdviceCreateOneWithoutCommentsInput {
  create: AdviceCreateWithoutCommentsInput
  connect: AdviceWhereUniqueInput
}

input AdviceCreateWithoutCommentsInput {
  id: ID
  title: String!
  content: String!
  owner: UserCreateOneWithoutAdvicesInput!
}

input AdviceCreateWithoutOwnerInput {
  id: ID
  title: String!
  content: String!
  comments: CommentCreateManyWithoutAdvicesInput
}

type AdviceEdge {
  node: Advice!
  cursor: String!
}

enum AdviceOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  content_ASC
  content_DESC
}

type AdvicePreviousValues {
  id: ID!
  title: String!
  content: String!
}

input AdviceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [AdviceScalarWhereInput!]
  OR: [AdviceScalarWhereInput!]
  NOT: [AdviceScalarWhereInput!]
}

type AdviceSubscriptionPayload {
  mutation: MutationType!
  node: Advice
  updatedFields: [String!]
  previousValues: AdvicePreviousValues
}

input AdviceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AdviceWhereInput
  AND: [AdviceSubscriptionWhereInput!]
  OR: [AdviceSubscriptionWhereInput!]
  NOT: [AdviceSubscriptionWhereInput!]
}

input AdviceUpdateInput {
  title: String
  content: String
  owner: UserUpdateOneRequiredWithoutAdvicesInput
  comments: CommentUpdateManyWithoutAdvicesInput
}

input AdviceUpdateManyDataInput {
  title: String
  content: String
}

input AdviceUpdateManyMutationInput {
  title: String
  content: String
}

input AdviceUpdateManyWithoutOwnerInput {
  create: [AdviceCreateWithoutOwnerInput!]
  delete: [AdviceWhereUniqueInput!]
  connect: [AdviceWhereUniqueInput!]
  set: [AdviceWhereUniqueInput!]
  disconnect: [AdviceWhereUniqueInput!]
  update: [AdviceUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [AdviceUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [AdviceScalarWhereInput!]
  updateMany: [AdviceUpdateManyWithWhereNestedInput!]
}

input AdviceUpdateManyWithWhereNestedInput {
  where: AdviceScalarWhereInput!
  data: AdviceUpdateManyDataInput!
}

input AdviceUpdateOneWithoutCommentsInput {
  create: AdviceCreateWithoutCommentsInput
  update: AdviceUpdateWithoutCommentsDataInput
  upsert: AdviceUpsertWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  connect: AdviceWhereUniqueInput
}

input AdviceUpdateWithoutCommentsDataInput {
  title: String
  content: String
  owner: UserUpdateOneRequiredWithoutAdvicesInput
}

input AdviceUpdateWithoutOwnerDataInput {
  title: String
  content: String
  comments: CommentUpdateManyWithoutAdvicesInput
}

input AdviceUpdateWithWhereUniqueWithoutOwnerInput {
  where: AdviceWhereUniqueInput!
  data: AdviceUpdateWithoutOwnerDataInput!
}

input AdviceUpsertWithoutCommentsInput {
  update: AdviceUpdateWithoutCommentsDataInput!
  create: AdviceCreateWithoutCommentsInput!
}

input AdviceUpsertWithWhereUniqueWithoutOwnerInput {
  where: AdviceWhereUniqueInput!
  update: AdviceUpdateWithoutOwnerDataInput!
  create: AdviceCreateWithoutOwnerInput!
}

input AdviceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  owner: UserWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  AND: [AdviceWhereInput!]
  OR: [AdviceWhereInput!]
  NOT: [AdviceWhereInput!]
}

input AdviceWhereUniqueInput {
  id: ID
}

type AggregateActivity {
  count: Int!
}

type AggregateAddress {
  count: Int!
}

type AggregateAdvice {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Comment {
  id: ID!
  content: String!
  owner: User
  advices: Advice
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  content: String!
  owner: UserCreateOneWithoutCommentsInput
  advices: AdviceCreateOneWithoutCommentsInput
}

input CommentCreateManyWithoutAdvicesInput {
  create: [CommentCreateWithoutAdvicesInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutOwnerInput {
  create: [CommentCreateWithoutOwnerInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutAdvicesInput {
  id: ID
  content: String!
  owner: UserCreateOneWithoutCommentsInput
}

input CommentCreateWithoutOwnerInput {
  id: ID
  content: String!
  advices: AdviceCreateOneWithoutCommentsInput
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
}

type CommentPreviousValues {
  id: ID!
  content: String!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  content: String
  owner: UserUpdateOneWithoutCommentsInput
  advices: AdviceUpdateOneWithoutCommentsInput
}

input CommentUpdateManyDataInput {
  content: String
}

input CommentUpdateManyMutationInput {
  content: String
}

input CommentUpdateManyWithoutAdvicesInput {
  create: [CommentCreateWithoutAdvicesInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAdvicesInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAdvicesInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutOwnerInput {
  create: [CommentCreateWithoutOwnerInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutOwnerInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutOwnerInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateWithoutAdvicesDataInput {
  content: String
  owner: UserUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutOwnerDataInput {
  content: String
  advices: AdviceUpdateOneWithoutCommentsInput
}

input CommentUpdateWithWhereUniqueWithoutAdvicesInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutAdvicesDataInput!
}

input CommentUpdateWithWhereUniqueWithoutOwnerInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutOwnerDataInput!
}

input CommentUpsertWithWhereUniqueWithoutAdvicesInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutAdvicesDataInput!
  create: CommentCreateWithoutAdvicesInput!
}

input CommentUpsertWithWhereUniqueWithoutOwnerInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutOwnerDataInput!
  create: CommentCreateWithoutOwnerInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  owner: UserWhereInput
  advices: AdviceWhereInput
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

scalar Long

type Mutation {
  createActivity(data: ActivityCreateInput!): Activity!
  updateActivity(data: ActivityUpdateInput!, where: ActivityWhereUniqueInput!): Activity
  updateManyActivities(data: ActivityUpdateManyMutationInput!, where: ActivityWhereInput): BatchPayload!
  upsertActivity(where: ActivityWhereUniqueInput!, create: ActivityCreateInput!, update: ActivityUpdateInput!): Activity!
  deleteActivity(where: ActivityWhereUniqueInput!): Activity
  deleteManyActivities(where: ActivityWhereInput): BatchPayload!
  createAddress(data: AddressCreateInput!): Address!
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  upsertAddress(where: AddressWhereUniqueInput!, create: AddressCreateInput!, update: AddressUpdateInput!): Address!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  createAdvice(data: AdviceCreateInput!): Advice!
  updateAdvice(data: AdviceUpdateInput!, where: AdviceWhereUniqueInput!): Advice
  updateManyAdvices(data: AdviceUpdateManyMutationInput!, where: AdviceWhereInput): BatchPayload!
  upsertAdvice(where: AdviceWhereUniqueInput!, create: AdviceCreateInput!, update: AdviceUpdateInput!): Advice!
  deleteAdvice(where: AdviceWhereUniqueInput!): Advice
  deleteManyAdvices(where: AdviceWhereInput): BatchPayload!
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  activity(where: ActivityWhereUniqueInput!): Activity
  activities(where: ActivityWhereInput, orderBy: ActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Activity]!
  activitiesConnection(where: ActivityWhereInput, orderBy: ActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ActivityConnection!
  address(where: AddressWhereUniqueInput!): Address
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address]!
  addressesConnection(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressConnection!
  advice(where: AdviceWhereUniqueInput!): Advice
  advices(where: AdviceWhereInput, orderBy: AdviceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Advice]!
  advicesConnection(where: AdviceWhereInput, orderBy: AdviceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AdviceConnection!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

enum Role {
  RESIDENT
  WORKER
  MANAGER
}

enum Sex {
  MALE
  FEMALE
}

enum Status {
  PENDING
  APPROVED
  REJECTED
}

type Subscription {
  activity(where: ActivitySubscriptionWhereInput): ActivitySubscriptionPayload
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
  advice(where: AdviceSubscriptionWhereInput): AdviceSubscriptionPayload
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  phoneNumber: String!
  idNumber: String!
  password: String
  role: Role!
  sex: Sex
  address: Address
  activities(where: ActivityWhereInput, orderBy: ActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Activity!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  advices(where: AdviceWhereInput, orderBy: AdviceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Advice!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  phoneNumber: String!
  idNumber: String!
  password: String
  role: Role!
  sex: Sex
  address: AddressCreateOneWithoutUsersInput
  activities: ActivityCreateManyWithoutOwnerInput
  comments: CommentCreateManyWithoutOwnerInput
  advices: AdviceCreateManyWithoutOwnerInput
}

input UserCreateManyWithoutAddressInput {
  create: [UserCreateWithoutAddressInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneWithoutActivitiesInput {
  create: UserCreateWithoutActivitiesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutAdvicesInput {
  create: UserCreateWithoutAdvicesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutActivitiesInput {
  id: ID
  name: String!
  phoneNumber: String!
  idNumber: String!
  password: String
  role: Role!
  sex: Sex
  address: AddressCreateOneWithoutUsersInput
  comments: CommentCreateManyWithoutOwnerInput
  advices: AdviceCreateManyWithoutOwnerInput
}

input UserCreateWithoutAddressInput {
  id: ID
  name: String!
  phoneNumber: String!
  idNumber: String!
  password: String
  role: Role!
  sex: Sex
  activities: ActivityCreateManyWithoutOwnerInput
  comments: CommentCreateManyWithoutOwnerInput
  advices: AdviceCreateManyWithoutOwnerInput
}

input UserCreateWithoutAdvicesInput {
  id: ID
  name: String!
  phoneNumber: String!
  idNumber: String!
  password: String
  role: Role!
  sex: Sex
  address: AddressCreateOneWithoutUsersInput
  activities: ActivityCreateManyWithoutOwnerInput
  comments: CommentCreateManyWithoutOwnerInput
}

input UserCreateWithoutCommentsInput {
  id: ID
  name: String!
  phoneNumber: String!
  idNumber: String!
  password: String
  role: Role!
  sex: Sex
  address: AddressCreateOneWithoutUsersInput
  activities: ActivityCreateManyWithoutOwnerInput
  advices: AdviceCreateManyWithoutOwnerInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  idNumber_ASC
  idNumber_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
  sex_ASC
  sex_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  phoneNumber: String!
  idNumber: String!
  password: String
  role: Role!
  sex: Sex
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  idNumber: String
  idNumber_not: String
  idNumber_in: [String!]
  idNumber_not_in: [String!]
  idNumber_lt: String
  idNumber_lte: String
  idNumber_gt: String
  idNumber_gte: String
  idNumber_contains: String
  idNumber_not_contains: String
  idNumber_starts_with: String
  idNumber_not_starts_with: String
  idNumber_ends_with: String
  idNumber_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  sex: Sex
  sex_not: Sex
  sex_in: [Sex!]
  sex_not_in: [Sex!]
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  phoneNumber: String
  idNumber: String
  password: String
  role: Role
  sex: Sex
  address: AddressUpdateOneWithoutUsersInput
  activities: ActivityUpdateManyWithoutOwnerInput
  comments: CommentUpdateManyWithoutOwnerInput
  advices: AdviceUpdateManyWithoutOwnerInput
}

input UserUpdateManyDataInput {
  name: String
  phoneNumber: String
  idNumber: String
  password: String
  role: Role
  sex: Sex
}

input UserUpdateManyMutationInput {
  name: String
  phoneNumber: String
  idNumber: String
  password: String
  role: Role
  sex: Sex
}

input UserUpdateManyWithoutAddressInput {
  create: [UserCreateWithoutAddressInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutAddressInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutAddressInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredWithoutActivitiesInput {
  create: UserCreateWithoutActivitiesInput
  update: UserUpdateWithoutActivitiesDataInput
  upsert: UserUpsertWithoutActivitiesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutAdvicesInput {
  create: UserCreateWithoutAdvicesInput
  update: UserUpdateWithoutAdvicesDataInput
  upsert: UserUpsertWithoutAdvicesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  update: UserUpdateWithoutCommentsDataInput
  upsert: UserUpsertWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutActivitiesDataInput {
  name: String
  phoneNumber: String
  idNumber: String
  password: String
  role: Role
  sex: Sex
  address: AddressUpdateOneWithoutUsersInput
  comments: CommentUpdateManyWithoutOwnerInput
  advices: AdviceUpdateManyWithoutOwnerInput
}

input UserUpdateWithoutAddressDataInput {
  name: String
  phoneNumber: String
  idNumber: String
  password: String
  role: Role
  sex: Sex
  activities: ActivityUpdateManyWithoutOwnerInput
  comments: CommentUpdateManyWithoutOwnerInput
  advices: AdviceUpdateManyWithoutOwnerInput
}

input UserUpdateWithoutAdvicesDataInput {
  name: String
  phoneNumber: String
  idNumber: String
  password: String
  role: Role
  sex: Sex
  address: AddressUpdateOneWithoutUsersInput
  activities: ActivityUpdateManyWithoutOwnerInput
  comments: CommentUpdateManyWithoutOwnerInput
}

input UserUpdateWithoutCommentsDataInput {
  name: String
  phoneNumber: String
  idNumber: String
  password: String
  role: Role
  sex: Sex
  address: AddressUpdateOneWithoutUsersInput
  activities: ActivityUpdateManyWithoutOwnerInput
  advices: AdviceUpdateManyWithoutOwnerInput
}

input UserUpdateWithWhereUniqueWithoutAddressInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutAddressDataInput!
}

input UserUpsertWithoutActivitiesInput {
  update: UserUpdateWithoutActivitiesDataInput!
  create: UserCreateWithoutActivitiesInput!
}

input UserUpsertWithoutAdvicesInput {
  update: UserUpdateWithoutAdvicesDataInput!
  create: UserCreateWithoutAdvicesInput!
}

input UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput!
  create: UserCreateWithoutCommentsInput!
}

input UserUpsertWithWhereUniqueWithoutAddressInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutAddressDataInput!
  create: UserCreateWithoutAddressInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  idNumber: String
  idNumber_not: String
  idNumber_in: [String!]
  idNumber_not_in: [String!]
  idNumber_lt: String
  idNumber_lte: String
  idNumber_gt: String
  idNumber_gte: String
  idNumber_contains: String
  idNumber_not_contains: String
  idNumber_starts_with: String
  idNumber_not_starts_with: String
  idNumber_ends_with: String
  idNumber_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  sex: Sex
  sex_not: Sex
  sex_in: [Sex!]
  sex_not_in: [Sex!]
  address: AddressWhereInput
  activities_every: ActivityWhereInput
  activities_some: ActivityWhereInput
  activities_none: ActivityWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  advices_every: AdviceWhereInput
  advices_some: AdviceWhereInput
  advices_none: AdviceWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  phoneNumber: String
  idNumber: String
}
`